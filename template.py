from extensions.output_template.tags import SimpleText, tag_name_to_class
from functools import partial
from re import Scanner


class Template:
    RE_TYPE_IGNORED = 0
    RE_TYPE_TAG_OPEN = 1
    RE_TYPE_ATTRIBUTE = 2
    RE_TYPE_NONPAIR = 3
    RE_TYPE_END_OF_TAG = 4
    RE_TYPE_TAG_CLOSE = 5
    RE_TYPE_WHITESPACE = 6
    RE_TYPE_TEXT = 7
    RES = [
        # https://stackoverflow.com/questions/1732348#answer-1732454
        (RE_TYPE_TAG_OPEN, r'\<[ \t]*[a-zA-Z]+'),                   # <tag
        (RE_TYPE_ATTRIBUTE, r'[ \t]+[a-zA-Z]+\s*=\s*"[^"]*"'),      # attribute="value"
        (RE_TYPE_ATTRIBUTE, r"[ \t]+[a-zA-Z]+\s*=\s*'[^']*'"),      # attribute='value'
        (RE_TYPE_NONPAIR, r'[ \t]*/[ \t]*\>'),                      # />
        (RE_TYPE_END_OF_TAG, r'[ \t]*\>'),                          # >
        (RE_TYPE_TAG_CLOSE, r'\<[ \t]*/[ \t]*[a-zA-Z]+[ \t]*\>'),   # </tag>
        (RE_TYPE_IGNORED, r'\n\s*'),                                # newline and whitespace after it
        (RE_TYPE_WHITESPACE, r'\s+'),                               # whitespace
        (RE_TYPE_TEXT, r'[^\<\s]+'),                                # everything else
    ]

    def __init__(self, text: str):
        # Intentionally avoiding to call this 'tokens'
        # to differentiate it from tokens generated by LLM
        self.template_pieces = []
        self.active_tag = None
        self.last_tag = None
        self.init_template(text)

    def init_template(self, text: str):
        self.stop()
        scanner = Scanner([
            (r, partial((lambda t, _, x: (t, x)), tp))
            for (tp, r) in self.RES
        ])
        text = text.replace("\r", "").strip(" \t")
        self.template_pieces, rest = scanner.scan(text)
        self.template_pieces = [ p for p in self.template_pieces if p[0] ]  # remove RE_TYPE_IGNORED
        assert not rest, "template parsing failed"
        # print("\n### template initialized")

    def move_forward(self, token_id: int):
        if self.last_tag:
            # Inform last generated tag about accepted token

            if self.last_tag.accepts(token_id) > 0:
                # print("A## %6s %12s %s" % (token_id, repr(decode([token_id])), self.last_tag.debug()))
                self.active_tag = self.last_tag
        self.last_tag = None

    def stop(self):
        self.active_tag = None
        self.last_tag = None
        self.template_pieces = []

    def get_initial_text(self):
        """
        Unless template starts with token right away, returns SimpleText instance with initial text.
        Returns SimpleText with empty string if template starts with token.
        """
        rv = []
        while self.template_pieces and self.get_next_tag_type() not in (self.RE_TYPE_TAG_OPEN, self.RE_TYPE_TAG_CLOSE):
            (_, text), *self.template_pieces = self.template_pieces
            rv.append(text)
        return SimpleText("".join(rv))

    def get_next_tag(self):
        assert not self.last_tag
        if self.active_tag:
            self.last_tag = self.active_tag
            self.active_tag = None
        else:
            self.last_tag = self.parse_next_tag()
        return self.last_tag

    def get_next_tag_type(self):
        return self.template_pieces[0][0] if self.template_pieces else 0

    def parse_next_tag(self, start_tag=None):
        """
        Parses next tag into TemplateTag instance.
        May return SimpleText or None if there is no more pieces of template left
        Called from TemplatingLogitsProcessor.
        """
        if not self.template_pieces:
            # Done entire template
            return None
        elif self.get_next_tag_type() not in (self.RE_TYPE_TAG_OPEN, self.RE_TYPE_TAG_CLOSE):
            # Not a tag
            return self.get_initial_text()
        elif self.get_next_tag_type() == self.RE_TYPE_TAG_CLOSE:
            if start_tag:
                (_, tag_name), *self.template_pieces = self.template_pieces
                tag_name = tag_name.strip("</>").lower()
                # TODO: compare with start_tag.tag_name to make sure they match? Do I care?
                return None
            else:
            # Unexpected closing tag. Dump it as text and hope for best
                return self.get_initial_text()
        else:
            # Yes, a tag
            (_, tag_name) = self.template_pieces[0]
            tag_name = tag_name.strip("< ").lower()
            if tag_name not in tag_name_to_class:
                # Invalid or unknown tag, just dump it as text and hope for best
                return self.get_initial_text()

            self.template_pieces = self.template_pieces[1:]

            # Parse arguments, if any
            attrs = {}
            while self.get_next_tag_type() == self.RE_TYPE_ATTRIBUTE:
                (_, text), *self.template_pieces = self.template_pieces
                k, v = text.split("=", 1)
                k, v = k.strip(" \t"), v.strip(" \t")
                v = v.strip(v[-1])
                attrs[k] = v

            # Ignore everything until end of tag
            while self.template_pieces and self.get_next_tag_type() not in (self.RE_TYPE_END_OF_TAG, self.RE_TYPE_NONPAIR):
                _, *self.template_pieces = self.template_pieces

            tag = tag_name_to_class[tag_name](attrs=attrs)

            if not self.template_pieces:
                # Unclosed tag
                pass
            elif self.get_next_tag_type() == self.RE_TYPE_NONPAIR:
                # Nonpair tag
                self.template_pieces = self.template_pieces[1:]
            else:
                # Normal <tag>
                self.template_pieces = self.template_pieces[1:]
                # Pair tag, check for children
                child = self.parse_next_tag(tag)
                while child:
                    tag.children.append(child)
                    child = self.parse_next_tag(tag)

            tag.finalize()
            return tag
